# Token Robustness Campaign â€” Implementation Plan

> **Implementation requirement**: Every listed ticket here maps to a concrete code or QA change. Before any ticket is marked complete, the described work must land in the repository (code, tests, documentation, or scripted verification).

## Overview
This plan turns each token-robustness campaign ticket into a concrete code and QA task. Every row pairs a component with a defined action, the file that owns it, and implementation guidance so the backlog is ready for follow-up.
| Component | Action | Implementation Notes |
|---|---|---|
| raise_af remediation notes | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/raise_af.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| raise_af remediation notes | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/raise_af.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| raise_af remediation notes | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/raise_af.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| raise_af remediation notes | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/raise_af.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| raise_af remediation notes | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/raise_af.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| raise_af remediation notes | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/raise_af.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| raise_af remediation notes | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/raise_af.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| raise_af remediation notes | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| raise_af remediation notes | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/raise_af.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| raise_af remediation notes | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/raise_af.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| raise_af duplicate guard | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/raise_af.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| raise_af duplicate guard | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/raise_af.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| raise_af duplicate guard | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/raise_af.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| raise_af duplicate guard | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/raise_af.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| raise_af duplicate guard | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/raise_af.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| raise_af duplicate guard | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/raise_af.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| raise_af duplicate guard | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/raise_af.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| raise_af duplicate guard | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| raise_af duplicate guard | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/raise_af.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| raise_af duplicate guard | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/raise_af.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| do_af dispatcher queueing | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/do_af.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| do_af dispatcher queueing | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/do_af.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| do_af dispatcher queueing | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/do_af.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| do_af dispatcher queueing | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/do_af.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| do_af dispatcher queueing | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/do_af.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| do_af dispatcher queueing | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/do_af.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| do_af dispatcher queueing | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/do_af.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| do_af dispatcher queueing | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| do_af dispatcher queueing | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/do_af.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| do_af dispatcher queueing | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/do_af.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| ai_client provider fallback | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/ai_client.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| ai_client provider fallback | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/ai_client.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| ai_client provider fallback | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/ai_client.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| ai_client provider fallback | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/ai_client.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| ai_client provider fallback | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/ai_client.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| ai_client provider fallback | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/ai_client.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| ai_client provider fallback | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/ai_client.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| ai_client provider fallback | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| ai_client provider fallback | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/ai_client.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| ai_client provider fallback | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/ai_client.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| state_paths resolution and gating | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/state_paths.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| state_paths resolution and gating | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/state_paths.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| state_paths resolution and gating | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/state_paths.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| state_paths resolution and gating | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/state_paths.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| state_paths resolution and gating | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/state_paths.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| state_paths resolution and gating | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/state_paths.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| state_paths resolution and gating | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/state_paths.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| state_paths resolution and gating | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| state_paths resolution and gating | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/state_paths.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| state_paths resolution and gating | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/state_paths.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| config loader normalization | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/config.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| config loader normalization | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/config.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| config loader normalization | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/config.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| config loader normalization | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/config.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| config loader normalization | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/config.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| config loader normalization | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/config.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| config loader normalization | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/config.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| config loader normalization | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| config loader normalization | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/config.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| config loader normalization | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/config.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| persistence.ticket_repo writes | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/persistence/ticket_repo.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| persistence.ticket_repo writes | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/persistence/ticket_repo.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| persistence.ticket_repo writes | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/persistence/ticket_repo.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| persistence.ticket_repo writes | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/persistence/ticket_repo.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| persistence.ticket_repo writes | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/persistence/ticket_repo.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| persistence.ticket_repo writes | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/persistence/ticket_repo.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| persistence.ticket_repo writes | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/persistence/ticket_repo.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| persistence.ticket_repo writes | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| persistence.ticket_repo writes | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/persistence/ticket_repo.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| persistence.ticket_repo writes | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/persistence/ticket_repo.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| persistence.database WAL tuning | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/persistence/database.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| persistence.database WAL tuning | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/persistence/database.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| persistence.database WAL tuning | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/persistence/database.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| persistence.database WAL tuning | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/persistence/database.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| persistence.database WAL tuning | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/persistence/database.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| persistence.database WAL tuning | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/persistence/database.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| persistence.database WAL tuning | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/persistence/database.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| persistence.database WAL tuning | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| persistence.database WAL tuning | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/persistence/database.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| persistence.database WAL tuning | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/persistence/database.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| persistence.queue pruning | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/persistence/queue.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| persistence.queue pruning | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/persistence/queue.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| persistence.queue pruning | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/persistence/queue.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| persistence.queue pruning | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/persistence/queue.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| persistence.queue pruning | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/persistence/queue.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| persistence.queue pruning | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/persistence/queue.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| persistence.queue pruning | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/persistence/queue.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| persistence.queue pruning | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| persistence.queue pruning | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/persistence/queue.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| persistence.queue pruning | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/persistence/queue.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| persistence.manager transactions | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/persistence/manager.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| persistence.manager transactions | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/persistence/manager.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| persistence.manager transactions | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/persistence/manager.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| persistence.manager transactions | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/persistence/manager.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| persistence.manager transactions | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/persistence/manager.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| persistence.manager transactions | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/persistence/manager.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| persistence.manager transactions | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/persistence/manager.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| persistence.manager transactions | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| persistence.manager transactions | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/persistence/manager.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| persistence.manager transactions | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/persistence/manager.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| log_utils atomic file writes | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/log_utils.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| log_utils atomic file writes | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/log_utils.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| log_utils atomic file writes | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/log_utils.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| log_utils atomic file writes | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/log_utils.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| log_utils atomic file writes | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/log_utils.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| log_utils atomic file writes | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/log_utils.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| log_utils atomic file writes | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/log_utils.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| log_utils atomic file writes | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| log_utils atomic file writes | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/log_utils.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| log_utils atomic file writes | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/log_utils.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| health monitor sampling | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/health.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| health monitor sampling | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/health.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| health monitor sampling | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/health.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| health monitor sampling | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/health.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| health monitor sampling | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/health.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| health monitor sampling | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/health.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| health monitor sampling | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/health.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| health monitor sampling | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| health monitor sampling | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/health.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| health monitor sampling | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/health.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| quarantine isolation paths | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/quarantine.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| quarantine isolation paths | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/quarantine.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| quarantine isolation paths | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/quarantine.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| quarantine isolation paths | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/quarantine.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| quarantine isolation paths | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/quarantine.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| quarantine isolation paths | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/quarantine.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| quarantine isolation paths | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/quarantine.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| quarantine isolation paths | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| quarantine isolation paths | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/quarantine.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| quarantine isolation paths | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/quarantine.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| bootstrap lifecycle hooks | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/bootstrap.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| bootstrap lifecycle hooks | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/bootstrap.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| bootstrap lifecycle hooks | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/bootstrap.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| bootstrap lifecycle hooks | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/bootstrap.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| bootstrap lifecycle hooks | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/bootstrap.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| bootstrap lifecycle hooks | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/bootstrap.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| bootstrap lifecycle hooks | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/bootstrap.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| bootstrap lifecycle hooks | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| bootstrap lifecycle hooks | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/bootstrap.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| bootstrap lifecycle hooks | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/bootstrap.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| api server error responses | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/api.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| api server error responses | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/api.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| api server error responses | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/api.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| api server error responses | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/api.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| api server error responses | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/api.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| api server error responses | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/api.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| api server error responses | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/api.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| api server error responses | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| api server error responses | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/api.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| api server error responses | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/api.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| simple_ticket_attack generator | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/simple_ticket_attack.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| simple_ticket_attack generator | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/simple_ticket_attack.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| simple_ticket_attack generator | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/simple_ticket_attack.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| simple_ticket_attack generator | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/simple_ticket_attack.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| simple_ticket_attack generator | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/simple_ticket_attack.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| simple_ticket_attack generator | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/simple_ticket_attack.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| simple_ticket_attack generator | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/simple_ticket_attack.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| simple_ticket_attack generator | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| simple_ticket_attack generator | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/simple_ticket_attack.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| simple_ticket_attack generator | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/simple_ticket_attack.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| security.rate_limiter pipeline | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/security/rate_limiter.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| security.rate_limiter pipeline | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/security/rate_limiter.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| security.rate_limiter pipeline | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/security/rate_limiter.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| security.rate_limiter pipeline | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/security/rate_limiter.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| security.rate_limiter pipeline | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/security/rate_limiter.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| security.rate_limiter pipeline | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/security/rate_limiter.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| security.rate_limiter pipeline | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/security/rate_limiter.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| security.rate_limiter pipeline | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| security.rate_limiter pipeline | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/security/rate_limiter.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| security.rate_limiter pipeline | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/security/rate_limiter.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| security.secrets_scanner sanitization | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/security/secrets_scanner.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| security.secrets_scanner sanitization | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/security/secrets_scanner.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| security.secrets_scanner sanitization | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/security/secrets_scanner.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| security.secrets_scanner sanitization | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/security/secrets_scanner.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| security.secrets_scanner sanitization | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/security/secrets_scanner.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| security.secrets_scanner sanitization | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/security/secrets_scanner.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| security.secrets_scanner sanitization | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/security/secrets_scanner.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| security.secrets_scanner sanitization | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| security.secrets_scanner sanitization | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/security/secrets_scanner.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| security.secrets_scanner sanitization | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/security/secrets_scanner.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| plugins.loader sandboxing | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/plugins/loader.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| plugins.loader sandboxing | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/plugins/loader.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| plugins.loader sandboxing | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/plugins/loader.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| plugins.loader sandboxing | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/plugins/loader.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| plugins.loader sandboxing | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/plugins/loader.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| plugins.loader sandboxing | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/plugins/loader.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| plugins.loader sandboxing | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/plugins/loader.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| plugins.loader sandboxing | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| plugins.loader sandboxing | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/plugins/loader.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| plugins.loader sandboxing | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/plugins/loader.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
| plugins.registry observability | trim remediation note boilerplate and measure token deltas before dispatch; clamp AI payloads under 2000 tokens with a dry-run preview path | In src/actifix/plugins/registry.py, tighten the AI remediation builder so it strips boilerplate, tracks token deltas, and exposes a dry-run preview helper that caps dispatch payloads under 2000 tokens. |
| plugins.registry observability | stream and truncate stack traces plus file context to 4KB while preserving first/last lines; add regression test that asserts truncation boundaries | Implement a 4KB truncation helper inside src/actifix/plugins/registry.py so stack traces and file context keep first/last lines, and add a regression test that asserts the boundary behavior. |
| plugins.registry observability | add AFLog/ACTIFIX roll rotation once files approach 8MB and verify append_with_guard keeps writes atomic under concurrent load | Coordinate changes between src/actifix/plugins/registry.py and src/actifix/log_utils.py to rotate AFLog/ACTIFIX files once they near 8MB while keeping append_with_guard atomic under concurrent writes. |
| plugins.registry observability | deduplicate environment and state snapshots so repeated captures share a cached blob; ensure secrets stay redacted after caching | Add caching of sanitized environment/state snapshots in src/actifix/plugins/registry.py so repeated captures reuse the same blob while ensuring secrets stay redacted before persistence. |
| plugins.registry observability | cache configuration and path lookups per process to avoid recomputing system_state for every ticket batch; emit metrics to confirm reduced overhead | Cache Actifix config and path lookups inside src/actifix/plugins/registry.py, emit a cache-health metric, and reuse the cached snapshot whenever system_state is recomputed. |
| plugins.registry observability | enforce structured ticket messaging with root-cause, impact, and action sections to keep detail dense but token-light; validate with unit tests | Enhance src/actifix/plugins/registry.py with a structured message builder that enforces root-cause, impact, and action sections, and add a unit test that validates the compact output. |
| plugins.registry observability | compact fallback queue entries by stripping empty fields and trimming whitespace, then replay to confirm no data loss and minimal file growth | Trim empty fields and whitespace from fallback queue payloads inside src/actifix/plugins/registry.py and related helpers, then add a replay test to prove no data loss while reducing queue size. |
| plugins.registry observability | run a P1 load test that fires 500 synthetic tickets and confirms WAL/DB growth remains linear and throttler bypass does not leak memory | Create or extend a P1 load test (e.g., test/load_token_robustness.py) that fires 500 synthetic tickets to verify WAL/DB growth stays linear and there are no throttler leaks. |
| plugins.registry observability | shard AI dispatch and correlation IDs by run_label so prompts stay small per shard; add guardrails to block oversize payloads before queueing | Shard AI dispatch and correlation IDs by run_label inside src/actifix/plugins/registry.py and src/actifix/ai_client.py so each shard keeps prompts bounded and rejects oversize payloads early. |
| plugins.registry observability | gate capture_context by priority so P1 tickets default to minimal blobs unless explicitly requested; log token savings and throttle interaction | Gate capture_context in src/actifix/plugins/registry.py by ticket priority so P1 uses minimal blobs unless requested, while logging token savings and how throttler metadata changes. |
